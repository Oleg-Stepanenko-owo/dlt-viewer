diff --git a/qdlt/qdltmsg.cpp b/qdlt/qdltmsg.cpp
index c63aacf..bb17af2 100644
--- a/qdlt/qdltmsg.cpp
+++ b/qdlt/qdltmsg.cpp
@@ -20,8 +20,10 @@
  */
 
 #include <QtDebug>
+#include <iostream>
 
 #include "qdlt.h"
+#include "settingsdialog.h"
 
 extern "C"
 {
@@ -499,22 +501,51 @@ void QDltMsg::removeArgument(int index)
 }
 
 
-QString QDltMsg::toStringHeader() const
+QString QDltMsg::toStringHeader( const SettingsDialog* settings ) const
 {
     QString text;
     text.reserve(1024);
 
-    text += QString("%1.%2").arg(getTimeString()).arg(getMicroseconds(),6,10,QLatin1Char('0'));
-    text += QString(" %1.%2").arg(getTimestamp()/10000).arg(getTimestamp()%10000,4,10,QLatin1Char('0'));
-    text += QString(" %1").arg(getMessageCounter());
-    text += QString(" %1").arg(getEcuid());
-    text += QString(" %1").arg(getApid());
-    text += QString(" %1").arg(getCtid());
-    text += QString(" %1").arg(getSessionid());
-    text += QString(" %2").arg(getTypeString());
-    text += QString(" %2").arg(getSubtypeString());
-    text += QString(" %2").arg(getModeString());
-    text += QString(" %1").arg(getNumberOfArguments());
+    if( settings == NULL )
+    {
+        text += QString(" %1.%2").arg(getTimeString()).arg(getMicroseconds(),6,10,QLatin1Char('0'));
+        text += QString(" %1.%2").arg(getTimestamp()/10000).arg(getTimestamp()%10000,4,10,QLatin1Char('0'));
+        text += QString(" %1").arg(getMessageCounter());
+        text += QString(" %1").arg(getEcuid());
+        text += QString(" %1").arg(getApid());
+        text += QString(" %1").arg(getCtid());
+        text += QString(" %1").arg(getSessionid());
+        text += QString(" %2").arg(getTypeString());
+        text += QString(" %2").arg(getSubtypeString());
+        text += QString(" %2").arg(getModeString());
+        text += QString(" %1").arg(getNumberOfArguments());
+    }
+    else
+    {
+        text += '|';
+        if( settings->showTime)
+            text += QString("%1.%2|").arg(getTimeString()).arg(getMicroseconds(),6,10,QLatin1Char('0'));
+        if( settings->showTimestamp )
+            text += QString("%1.%2|").arg(getTimestamp()/10000).arg(getTimestamp()%10000,4,10,QLatin1Char('0'));
+        if( settings->showCount)
+            text += QString("%1|").arg(getMessageCounter());
+        if( settings->showEcuId )
+            text += QString("%1|").arg(getEcuid());
+        if( settings->showApId )
+            text += QString("%1|").arg(getApid());
+        if( settings->showCtId )
+            text += QString("%1|").arg(getCtid());
+        if( settings->showSessionId )
+            text += QString("%1|").arg(getSessionid());
+        if( settings->showType )
+            text += QString("%2|").arg(getTypeString());
+        if( settings->showSubtype )
+            text += QString("%2|").arg(getSubtypeString());
+        if( settings->showMode )
+            text += QString("%2|").arg(getModeString());
+        if( settings->showArguments )
+            text += QString("%1|").arg(getNumberOfArguments());
+    }
 
     return text;
 }
diff --git a/qdlt/qdltmsg.h b/qdlt/qdltmsg.h
index f3a62ad..3b62a42 100644
--- a/qdlt/qdltmsg.h
+++ b/qdlt/qdltmsg.h
@@ -32,6 +32,8 @@
 
 #include "export_rules.h"
 
+
+class SettingsDialog;
 //! Access to a DLT message.
 /*!
   This class provide access to a single DLT message from a DLT log file.
@@ -425,7 +427,7 @@ public:
     /*!
       \return The header string.
     */
-    QString toStringHeader() const;
+    QString toStringHeader( const SettingsDialog* settings = NULL ) const;
 
     //! Print Payload content into a string.
     /*!
diff --git a/src/dltexporter.cpp b/src/dltexporter.cpp
index e21a555..95df6dc 100644
--- a/src/dltexporter.cpp
+++ b/src/dltexporter.cpp
@@ -2,6 +2,7 @@
 #include <QMessageBox>
 #include <QApplication>
 #include <QClipboard>
+#include <QString>
 
 #include "dltexporter.h"
 #include "fieldnames.h"
@@ -18,6 +19,7 @@ DltExporter::DltExporter(QObject *parent) :
     selection = NULL;
     exportFormat = FormatDlt;
     exportSelection = SelectionAll;
+    m_settings = NULL;
 }
 
 QString DltExporter::escapeCSVValue(QString arg)
@@ -184,6 +186,57 @@ bool DltExporter::getMsg(int num,QDltMsg &msg,QByteArray &buf)
     return msg.setMsg(buf);
 }
 
+void DltExporter::setSettings( const SettingsDialog* setting )
+{
+  m_settings = setting;
+}
+
+const QString DltExporter::extract_payload( QDltFile *from, QModelIndexList *selection )
+{
+    QDltMsg msg;
+    QByteArray buf;
+
+    this->from = from;
+    exportSelection = DltExporter::SelectionSelected;
+    exportFormat = DltExporter::FormatUTF8;
+    this->selection = selection;
+
+    /* Sort the selection list and create Row list */
+    if(exportSelection == DltExporter::SelectionSelected && selection != NULL)
+    {
+        qSort(selection->begin(), selection->end());
+        selectedRows.clear();
+        for(int num=0;num<selection->count();num++)
+        {
+            QModelIndex index = selection->at(num);
+            if(index.column() == 0)
+                selectedRows.append(index.row());
+        }
+    }
+
+    QString return_val;
+    for( int num = 0; num < selectedRows.size(); ++num )
+    {
+        if(!getMsg(num,msg,buf))
+        {
+            return QString("{ \"ERROR\":\"DLT Export getMsg() failed on msg\" }");
+        }
+        else
+        {
+            return_val += msg.toStringPayload().toUtf8().simplified();
+        }
+    }
+
+    return_val.replace("\"{\"", "{\"");
+    return_val.replace("}\" }", "} }");
+
+    QClipboard *clipboard = QApplication::clipboard();
+    clipboard->setText(return_val);
+
+
+    return return_val;
+}
+
 bool DltExporter::exportMsg(int num, QDltMsg &msg, QByteArray &buf)
 {
     if((exportFormat == DltExporter::FormatDlt)||(exportFormat == DltExporter::FormatDltDecoded))
@@ -196,14 +249,14 @@ bool DltExporter::exportMsg(int num, QDltMsg &msg, QByteArray &buf)
 
         /* get message ASCII text */
         if(exportSelection == DltExporter::SelectionAll)
-            text += QString("%1 ").arg(num);
+            text += QString("%1").arg(num);
         else if(exportSelection == DltExporter::SelectionFiltered)
-            text += QString("%1 ").arg(from->getMsgFilterPos(num));
+            text += QString("%1").arg(from->getMsgFilterPos(num));
         else if(exportSelection == DltExporter::SelectionSelected)
-            text += QString("%1 ").arg(from->getMsgFilterPos(selectedRows[num]));
+            text += QString("%1").arg(from->getMsgFilterPos(selectedRows[num]));
         else
             return false;
-        text += msg.toStringHeader();
+        text += msg.toStringHeader( m_settings );
         text += " ";
         text += msg.toStringPayload().simplified();
         text += "\n";
diff --git a/src/dltexporter.h b/src/dltexporter.h
index eba1684..4139f13 100644
--- a/src/dltexporter.h
+++ b/src/dltexporter.h
@@ -7,6 +7,7 @@
 #include <QTreeWidget>
 
 #include "qdlt.h"
+#include "settingsdialog.h"
 
 class DltExporter : public QObject
 {
@@ -64,6 +65,10 @@ public:
                              DltExporter::DltExportFormat exportFormat, DltExporter::DltExportSelection exportSelection, QModelIndexList *selection = 0);
 
 
+    const QString extract_payload( QDltFile *from, QModelIndexList *selection );
+
+    void setSettings( const SettingsDialog* setting );
+
 signals:
     
 public slots:
@@ -78,6 +83,7 @@ private:
     QList<int> selectedRows;
     DltExporter::DltExportFormat exportFormat;
     DltExporter::DltExportSelection exportSelection;
+    const SettingsDialog* m_settings;
 };
 
 #endif // DLTEXPORTER_H
diff --git a/src/mainwindow.cpp b/src/mainwindow.cpp
index be91528..f796fb6 100644
--- a/src/mainwindow.cpp
+++ b/src/mainwindow.cpp
@@ -18,6 +18,7 @@
  */
 
 #include <iostream>
+#include <memory>
 #include <QMimeData>
 #include <QTreeView>
 #include <QFileDialog>
@@ -39,6 +40,8 @@
 #include <QSerialPort>
 #include <QSerialPortInfo>
 #include <QNetworkProxyFactory>
+#include <QJsonDocument>
+#include "qjsoncontainer.h"
 
 /**
  * From QDlt.
@@ -274,23 +277,24 @@ void MainWindow::initView()
     //ui->tableView->setItemDelegate(delegate);
     //ui->tableView->setItemDelegateForColumn(FieldNames::Payload,delegate);
 
-    ui->tableView->setColumnWidth(0,50);
-    ui->tableView->setColumnWidth(1,150);
-    ui->tableView->setColumnWidth(2,70);
-    ui->tableView->setColumnWidth(3,40);
-    ui->tableView->setColumnWidth(4,40);
-    ui->tableView->setColumnWidth(5,40);
-    ui->tableView->setColumnWidth(6,40);
-    ui->tableView->setColumnWidth(7,50);
-    ui->tableView->setColumnWidth(8,50);
-    ui->tableView->setColumnWidth(9,50);
-    ui->tableView->setColumnWidth(10,40);
-    ui->tableView->setColumnWidth(11,40);
+    ui->tableView->setColumnWidth(0,35);
+    ui->tableView->setColumnWidth(1,110);
+    ui->tableView->setColumnWidth(2,50);
+    ui->tableView->setColumnWidth(3,45);
+    ui->tableView->setColumnWidth(4,45);
+    ui->tableView->setColumnWidth(5,45);
+    ui->tableView->setColumnWidth(6,45);
+    ui->tableView->setColumnWidth(7,45);
+    ui->tableView->setColumnWidth(8,45);
+    ui->tableView->setColumnWidth(9,45);
+    ui->tableView->setColumnWidth(10,35);
+    ui->tableView->setColumnWidth(11,35);
     ui->tableView->setColumnWidth(12,400);
 
+
     // Payload column expands as needed
     // horizontal scrolling
-    ui->tableView->horizontalHeader()->setSectionResizeMode(12, QHeaderView::ResizeToContents);
+    ui->tableView->horizontalHeader()->setSectionResizeMode(12, QHeaderView::Stretch);
     // Some decoder-plugins can create very long payloads, which in turn severly impact performance
     // So set some limit on what is displayed in the tableview. All details are always available using the message viewer-plugin
     ui->tableView->horizontalHeader()->setMaximumSectionSize(5000);
@@ -348,10 +352,13 @@ void MainWindow::initView()
     connect(settings, SIGNAL(FilterPathChanged()), this, SLOT(on_actionDefault_Filter_Reload_triggered()));
 
     searchComboBox = new QComboBox();
-    searchComboBox->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);
+    searchComboBox->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::MinimumExpanding);
     searchComboBox->setLineEdit(searchTextbox);
     searchComboBox->setInsertPolicy(QComboBox::InsertAtTop);
 
+    if( !settings->storedSearchStr.isEmpty() )
+    searchComboBox->addItem(settings->storedSearchStr);
+
     /* Initialize toolbars. Most of the construction and connection is done via the
      * UI file. See mainwindow.ui, ActionEditor and Signal & Slots editor */
     QList<QAction *> mainActions = ui->mainToolBar->actions();
@@ -413,6 +420,7 @@ void MainWindow::initSignalConnections()
 
 void MainWindow::initSearchTable()
 {
+    parseJSONDlg = new Parse_JSON( this );
 
     //init search Dialog
     searchDlg = new SearchDialog(this);
@@ -468,7 +476,6 @@ void MainWindow::initSearchTable()
     m_searchresultsTable->setColumnWidth(FieldNames::ArgCount,40);
     m_searchresultsTable->setColumnWidth(FieldNames::Payload,1000);
 
-
 }
 
 void MainWindow::initFileHandling()
@@ -1185,7 +1192,7 @@ void MainWindow::on_action_menuFile_Append_DLT_File_triggered()
 
 }
 
-void MainWindow::exportSelection(bool ascii = true,bool file = false)
+void MainWindow::exportSelection(bool ascii = true,bool file = false, bool custom = false )
 {
     Q_UNUSED(ascii);
     Q_UNUSED(file);
@@ -1193,6 +1200,7 @@ void MainWindow::exportSelection(bool ascii = true,bool file = false)
     QModelIndexList list = ui->tableView->selectionModel()->selection().indexes();
 
     DltExporter exporter;
+    exporter.setSettings( custom ? project.settings:NULL );
     exporter.exportMessages(&qfile,0,&pluginManager,DltExporter::FormatClipboard,DltExporter::SelectionSelected,&list);
 }
 
@@ -1787,9 +1795,10 @@ void MainWindow::applySettings()
 {
     QFont tableViewFont = ui->tableView->font();
     tableViewFont.setPointSize(settings->fontSize);
+    settings->my_font = tableViewFont;
     ui->tableView->setFont(tableViewFont);
     // Rescale the height of a row to choosen font size + 8 pixels
-    ui->tableView->verticalHeader()->setDefaultSectionSize(settings->fontSize+8);
+    ui->tableView->verticalHeader()->setDefaultSectionSize( settings->rowSize );
 
     settings->showIndex?ui->tableView->showColumn(0):ui->tableView->hideColumn(0);
     settings->showTime?ui->tableView->showColumn(1):ui->tableView->hideColumn(1);
@@ -1814,6 +1823,7 @@ void MainWindow::applySettings()
         draw_interval = 1000 / refreshRate;
     else
         draw_interval = 1000 / DEFAULT_REFRESH_RATE;
+
 }
 
 
@@ -3424,7 +3434,7 @@ void MainWindow::drawUpdatedView()
     if(settings->autoScroll) {
         ui->tableView->scrollToBottom();
     }
-
+    ui->tableView->verticalHeader()->setDefaultSectionSize( settings->rowSize );
 }
 
 void MainWindow::onTableViewSelectionChanged(const QItemSelection & selected, const QItemSelection & deselected)
@@ -5825,10 +5835,18 @@ void MainWindow::on_tableView_customContextMenuRequested(QPoint pos)
     QAction *action;
     QModelIndexList list = ui->tableView->selectionModel()->selection().indexes();
 
-    action = new QAction("&Copy Selection to Clipboard", this);
+    action = new QAction("&to Clipboard All Fields", this);
     connect(action, SIGNAL(triggered()), this, SLOT(on_action_menuConfig_Copy_to_clipboard_triggered()));
     menu.addAction(action);
 
+    action = new QAction("to Clipboard Visible Fields", this);
+    connect(action, SIGNAL(triggered()), this, SLOT(on_action_menuConfig_customCopy_to_clipboard_triggered()));
+    menu.addAction(action);
+
+    action = new QAction("parce JSON from current row", this);
+    connect(action, SIGNAL(triggered()), this, SLOT(on_actionaction_JSON_parse_triggered()));
+    menu.addAction(action);
+
     menu.addSeparator();
 
     action = new QAction("&Export...", this);
@@ -6094,7 +6112,7 @@ void MainWindow::on_action_menuConfig_Expand_All_ECUs_triggered()
 
 void MainWindow::on_action_menuConfig_Copy_to_clipboard_triggered()
 {
-    exportSelection(true,false);
+    exportSelection(true,false,false);
 }
 
 void MainWindow::on_action_menuFilter_Append_Filters_triggered()
@@ -6617,3 +6635,42 @@ void MainWindow::onSearchProgressChanged(bool isInProgress)
     ui->searchToolbar->setEnabled(!isInProgress);
     ui->dockWidgetProject->setEnabled(!isInProgress);
 }
+
+void MainWindow::on_actionStoreRegExp_triggered()
+{
+    settings->addSearchStr( searchDlg->getText().toStdString() );
+}
+
+void MainWindow::on_tableView_doubleClicked(const QModelIndex &index)
+{
+        QJsonDocument doc = QJsonDocument::fromJson( index.data().toString().toUtf8() );
+        QString clip_str;
+
+        if( !doc.isEmpty() )
+        {
+            QJsonObject json_obj = doc.object();
+            QJsonValue val = json_obj.take("function");
+            clip_str = val.toString();
+        }
+        else
+        {
+            clip_str = index.data().toString();
+        }
+
+        QClipboard *clipboard = QApplication::clipboard();
+        clipboard->setText( clip_str );
+}
+
+void MainWindow::on_action_menuConfig_customCopy_to_clipboard_triggered()
+{
+    exportSelection( true,false, true );
+}
+
+void MainWindow::on_actionaction_JSON_parse_triggered()
+{
+    QModelIndexList list = ui->tableView->selectionModel()->selection().indexes();
+    DltExporter exporter;
+
+    parseJSONDlg->loadJson( exporter.extract_payload( &qfile, &list ) ) ;
+    parseJSONDlg->open();
+}
diff --git a/src/mainwindow.h b/src/mainwindow.h
index f148e63..9c16769 100644
--- a/src/mainwindow.h
+++ b/src/mainwindow.h
@@ -33,6 +33,7 @@
 #include "project.h"
 #include "settingsdialog.h"
 #include "searchdialog.h"
+#include "parse_json.h"
 #include "optmanager.h"
 #include "qdlt.h"
 #include "dltsettingsmanager.h"
@@ -216,6 +217,8 @@ private:
     /* DLT File opened only Read only */
     bool isDltFileReadOnly;
 
+    Parse_JSON *parseJSONDlg;
+
     /* functions called in constructor */
     void initState();
     void initView();
@@ -237,7 +240,7 @@ private:
 
     void reloadLogFileDefaultFilter();
 
-    void exportSelection(bool ascii,bool file);
+    void exportSelection(bool ascii, bool file, bool custom);
     void exportSelection_searchTable();
 
     void ControlServiceRequest(EcuItem* ecuitem, int service_id );
@@ -507,6 +510,14 @@ private slots:
     void on_actionToggle_SortByTimeEnabled_triggered(bool checked);
 
 
+    void on_actionStoreRegExp_triggered();
+
+    void on_tableView_doubleClicked(const QModelIndex &index);
+
+    void on_action_menuConfig_customCopy_to_clipboard_triggered();
+
+    void on_actionaction_JSON_parse_triggered();
+
 public slots:
 
     void sendInjection(int index,QString applicationId,QString contextId,int serviceId,QByteArray data);
diff --git a/src/mainwindow.ui b/src/mainwindow.ui
index 6542b3f..9d7bb38 100644
--- a/src/mainwindow.ui
+++ b/src/mainwindow.ui
@@ -41,10 +41,13 @@
      <widget class="DltTableView" name="tableView">
       <property name="font">
        <font>
-        <family>Courier 10 Pitch</family>
+        <family>Ubuntu</family>
         <pointsize>8</pointsize>
        </font>
       </property>
+      <property name="cursor" stdset="0">
+       <cursorShape>ArrowCursor</cursorShape>
+      </property>
       <property name="contextMenuPolicy">
        <enum>Qt::CustomContextMenu</enum>
       </property>
@@ -69,13 +72,19 @@
       <property name="horizontalScrollMode">
        <enum>QAbstractItemView::ScrollPerPixel</enum>
       </property>
+      <property name="gridStyle">
+       <enum>Qt::SolidLine</enum>
+      </property>
       <attribute name="horizontalHeaderDefaultSectionSize">
-       <number>200</number>
+       <number>80</number>
       </attribute>
       <attribute name="horizontalHeaderStretchLastSection">
        <bool>false</bool>
       </attribute>
       <attribute name="verticalHeaderVisible">
+       <bool>true</bool>
+      </attribute>
+      <attribute name="verticalHeaderCascadingSectionResizes">
        <bool>false</bool>
       </attribute>
       <attribute name="verticalHeaderDefaultSectionSize">
@@ -91,7 +100,7 @@
      <x>0</x>
      <y>0</y>
      <width>1001</width>
-     <height>26</height>
+     <height>22</height>
     </rect>
    </property>
    <widget class="QMenu" name="menuFile">
@@ -287,6 +296,11 @@
    <addaction name="separator"/>
   </widget>
   <widget class="QToolBar" name="searchToolbar">
+   <property name="font">
+    <font>
+     <pointsize>11</pointsize>
+    </font>
+   </property>
    <property name="windowTitle">
     <string>toolBar</string>
    </property>
@@ -302,6 +316,7 @@
    <addaction name="separator"/>
    <addaction name="actionFindPrevious"/>
    <addaction name="actionFindNext"/>
+   <addaction name="actionStoreRegExp"/>
   </widget>
   <widget class="QStatusBar" name="statusBar"/>
   <widget class="QDockWidget" name="dockWidgetProject">
@@ -343,13 +358,18 @@
         <enum>QFrame::Plain</enum>
        </property>
        <layout class="QGridLayout" name="gridLayout">
-        <item row="2" column="1">
-         <widget class="QCheckBox" name="filtersEnabled">
+        <item row="0" column="0" colspan="3">
+         <widget class="QPushButton" name="applyConfig">
+          <property name="enabled">
+           <bool>false</bool>
+          </property>
           <property name="text">
-           <string>Filters Enabled</string>
+           <string>Apply Configuration</string>
           </property>
-          <property name="checked">
-           <bool>true</bool>
+          <property name="icon">
+           <iconset resource="resource.qrc">
+            <normaloff>:/toolbar/png/weather-storm.png</normaloff>
+            <disabledoff>:/toolbar/png/weather-clear.png</disabledoff>:/toolbar/png/weather-storm.png</iconset>
           </property>
          </widget>
         </item>
@@ -363,28 +383,23 @@
           </property>
          </widget>
         </item>
-        <item row="2" column="2">
-         <widget class="QCheckBox" name="checkBoxSortByTime">
+        <item row="3" column="0">
+         <widget class="QCheckBox" name="filtersEnabled">
           <property name="text">
-           <string>Sorted by Time</string>
+           <string>Filters Enabled</string>
           </property>
           <property name="checked">
            <bool>true</bool>
           </property>
          </widget>
         </item>
-        <item row="0" column="0" colspan="3">
-         <widget class="QPushButton" name="applyConfig">
-          <property name="enabled">
-           <bool>false</bool>
-          </property>
+        <item row="4" column="0">
+         <widget class="QCheckBox" name="checkBoxSortByTime">
           <property name="text">
-           <string>Apply Configuration</string>
+           <string>Sorted by Time</string>
           </property>
-          <property name="icon">
-           <iconset resource="resource.qrc">
-            <normaloff>:/toolbar/png/weather-storm.png</normaloff>
-            <disabledoff>:/toolbar/png/weather-clear.png</disabledoff>:/toolbar/png/weather-storm.png</iconset>
+          <property name="checked">
+           <bool>true</bool>
           </property>
          </widget>
         </item>
@@ -1490,31 +1505,48 @@
     <string>Toggle Sorted By Time</string>
    </property>
   </action>
+  <action name="actionStoreRegExp">
+   <property name="icon">
+    <iconset resource="resource.qrc">
+     <normaloff>:/toolbar/png/store.png</normaloff>:/toolbar/png/store.png</iconset>
+   </property>
+   <property name="text">
+    <string>StoreRegExp</string>
+   </property>
+  </action>
+  <action name="action_menuConfig_customCopy_to_clipboard">
+   <property name="text">
+    <string>Custom copy to Clipboard</string>
+   </property>
+  </action>
+  <action name="actionaction_JSON_parse">
+   <property name="text">
+    <string>action_JSON_parse</string>
+   </property>
+  </action>
  </widget>
  <layoutdefault spacing="6" margin="11"/>
  <customwidgets>
   <customwidget>
    <class>FilterTreeWidget</class>
    <extends>QTreeWidget</extends>
-   <header>filtertreewidget.h</header>
+   <header location="global">filtertreewidget.h</header>
   </customwidget>
   <customwidget>
    <class>PluginTreeWidget</class>
    <extends>QTreeWidget</extends>
-   <header>plugintreewidget.h</header>
+   <header location="global">plugintreewidget.h</header>
   </customwidget>
   <customwidget>
    <class>DltTableView</class>
    <extends>QTableView</extends>
-   <header>dlttableview.h</header>
+   <header location="global">dlttableview.h</header>
   </customwidget>
  </customwidgets>
  <tabstops>
   <tabstop>tableView</tabstop>
   <tabstop>applyConfig</tabstop>
   <tabstop>pluginsEnabled</tabstop>
-  <tabstop>filtersEnabled</tabstop>
-  <tabstop>checkBoxSortByTime</tabstop>
   <tabstop>pluginWidget</tabstop>
   <tabstop>tabWidget</tabstop>
   <tabstop>configWidget</tabstop>
diff --git a/src/parse_json.cpp b/src/parse_json.cpp
new file mode 100644
index 0000000..d24bfd2
--- /dev/null
+++ b/src/parse_json.cpp
@@ -0,0 +1,17 @@
+#include "parse_json.h"
+#include "ui_parse_json.h"
+
+Parse_JSON::Parse_JSON(QWidget *parent) :
+    QDialog(parent)
+  , ui(new Ui::Parse_JSON)
+  , parseJson( nullptr )
+
+{
+    ui->setupUi(this);
+    parseJson = std::unique_ptr<QJsonContainer>( new  QJsonContainer(ui->tab_parse) );
+}
+
+Parse_JSON::~Parse_JSON()
+{
+    delete ui;
+}
diff --git a/src/parse_json.h b/src/parse_json.h
new file mode 100644
index 0000000..05c9e56
--- /dev/null
+++ b/src/parse_json.h
@@ -0,0 +1,29 @@
+#ifndef PARSE_JSON_H
+#define PARSE_JSON_H
+
+#include <QDialog>
+#include <memory>
+#include "ui_parse_json.h"
+#include "qjsoncontainer.h"
+
+namespace Ui {
+class Parse_JSON;
+}
+
+class Parse_JSON : public QDialog
+{
+    Q_OBJECT
+
+public:
+    explicit Parse_JSON(QWidget *parent = 0);
+    ~Parse_JSON();
+
+    QWidget* getParseWidget() { return ui->tab_parse; }
+
+    void loadJson( const QString& val ) { if( parseJson ) parseJson->loadJson(val); }
+private:
+    Ui::Parse_JSON *ui;
+    std::unique_ptr<QJsonContainer> parseJson;
+};
+
+#endif // PARSE_JSON_H
diff --git a/src/parse_json.ui b/src/parse_json.ui
new file mode 100644
index 0000000..f519d4c
--- /dev/null
+++ b/src/parse_json.ui
@@ -0,0 +1,85 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>Parse_JSON</class>
+ <widget class="QDialog" name="Parse_JSON">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>592</width>
+    <height>586</height>
+   </rect>
+  </property>
+  <property name="windowTitle">
+   <string>Dialog</string>
+  </property>
+  <layout class="QVBoxLayout" name="verticalLayout_2">
+   <item>
+    <layout class="QVBoxLayout" name="verticalLayout">
+     <item>
+      <widget class="QTabWidget" name="tabWidget">
+       <property name="currentIndex">
+        <number>0</number>
+       </property>
+       <widget class="QWidget" name="tab_parse">
+        <attribute name="title">
+         <string>Parse</string>
+        </attribute>
+       </widget>
+       <widget class="QWidget" name="tab_2">
+        <attribute name="title">
+         <string>Tab 2</string>
+        </attribute>
+       </widget>
+      </widget>
+     </item>
+     <item>
+      <widget class="QDialogButtonBox" name="buttonBox">
+       <property name="orientation">
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="standardButtons">
+        <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
+       </property>
+      </widget>
+     </item>
+    </layout>
+   </item>
+  </layout>
+ </widget>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>accepted()</signal>
+   <receiver>Parse_JSON</receiver>
+   <slot>accept()</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>248</x>
+     <y>254</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>157</x>
+     <y>274</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>rejected()</signal>
+   <receiver>Parse_JSON</receiver>
+   <slot>reject()</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>316</x>
+     <y>260</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>286</x>
+     <y>274</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>
diff --git a/src/png/store.png b/src/png/store.png
new file mode 100644
index 0000000000000000000000000000000000000000..a512644df2ae0d248d77412558c2443b9307fde7
GIT binary patch
literal 2918
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
Q`~Uy|07*qoM6N<$f&#mk)c^nh

literal 0
HcmV?d00001

diff --git a/src/qjsoncontainer.cpp b/src/qjsoncontainer.cpp
new file mode 100644
index 0000000..b62048c
--- /dev/null
+++ b/src/qjsoncontainer.cpp
@@ -0,0 +1,738 @@
+/* Author: Yuriy Kuzin
+ * Description: widget to load JSON from file or http source
+ *              or you can paste it manualy into text area
+ *              evrytime model will be updated
+ *              it's possible to perform search in text view and json view
+ */
+#include "qjsoncontainer.h"
+
+QJsonContainer::QJsonContainer(QWidget *parent):
+    QWidget(parent)
+{
+    qDebug()<<"obj_layout parent";
+    obj_layout=new QVBoxLayout(parent);
+    obj_layout->setContentsMargins(QMargins(5,5,5,5));
+
+
+    qDebug()<<"treeview_groupbox parent";
+    treeview_groupbox=new QGroupBox(parent);
+    treeview_groupbox->setStyleSheet("QGroupBox {  border:0;}");
+
+    qDebug()<<"treeview_layout treeview_groupbox";
+    treeview_layout = new QVBoxLayout(treeview_groupbox);
+
+    qDebug()<<"treeview_layout treeview_groupbox";
+    treeview = new QTreeView(treeview_groupbox);
+    viewjson_plaintext=new QPlainTextEdit(treeview_groupbox);
+    viewjson_plaintext->setVisible(false);
+
+    QPalette p = viewjson_plaintext->palette();
+    p.setColor(QPalette::Highlight, QColor(Qt::blue));
+    p.setColor(QPalette::HighlightedText, QColor(Qt::lightGray));
+    viewjson_plaintext->setPalette(p);
+
+
+
+    showjson_pushbutton=new QPushButton(treeview_groupbox);
+    showjson_pushbutton->setText(tr("Show Json Text"));
+    showjson_pushbutton->setCheckable(true);
+
+    //QJsonDocument data1=QJsonDocument::fromJson("{\"subscription\":[{\"action\":0,\"event\":{\"GroupId\":0,\"Id\":0,\"IdType\":1},\"league\":{\"GroupId\":10001,\"Id\":1,\"IdType\":0},\"scores\":[1,3,2],\"sportId\":4},{\"action\":0,\"event\":{\"GroupId\":0,\"Id\":0,\"IdType\":1},\"league\":{\"GroupId\":1000,\"Id\":1,\"IdType\":0},\"scores\":[1,2],\"sportId\":4}]}");
+    //QString datastr=data1.toJson();
+    QString datastr="";
+    model = new QJsonModel(parent);
+    model->loadJson(datastr.toUtf8());
+    //connect some branch expanding signal/slot
+
+    treeview->setModel(model);
+
+    // add layout, insert checkbox and treview into it
+    //QVBoxLayout *treeview_layout = new QVBoxLayout(parent);
+
+
+    toolbar=new QToolBar();
+    //toolbar->setGeometry(0,21,509,458);
+    toolbar->setSizePolicy(QSizePolicy::Preferred,QSizePolicy::Preferred);
+    toolbar->setMovable(true);
+    toolbar->setFloatable(true);
+    toolbar->setAllowedAreas(Qt::AllToolBarAreas);
+
+    qDebug()<<"expandAll_Checkbox treeview_groupbox";
+    expandAll_Checkbox = new QCheckBox(toolbar);
+    expandAll_Checkbox->setText(QString(tr("Expand")));
+
+    sortObj_toolButton=new QToolButton(toolbar);
+    sortObj_toolButton->setText(tr("Sort"));
+    sortObj_toolButton->setToolTip(tr("Sort objects inside array\nmaybe helpful when order does not relevant"));
+
+    tools_layout=new QGridLayout(toolbar);
+    tools_layout->setContentsMargins(0,0,0,0);
+    find_lineEdit=new QLineEdit();
+    find_lineEdit->setPlaceholderText(tr("Serach for..."));
+    find_lineEdit->setToolTip(tr("Enter text and press enter to search"));
+    find_lineEdit->setSizePolicy(QSizePolicy::Minimum,QSizePolicy::Minimum);
+    findNext_toolbutton=new QToolButton(toolbar);
+    findNext_toolbutton->setText(">>");
+    findNext_toolbutton->setToolTip("Find Next");
+    findPrevious_toolbutton=new QToolButton(toolbar);
+    findPrevious_toolbutton->setText("<<");
+    findPrevious_toolbutton->setToolTip("Find Previous");
+    findCaseSensitivity_toolbutton=new QToolButton(toolbar);
+    findCaseSensitivity_toolbutton->setCheckable(true);
+    findCaseSensitivity_toolbutton->setIcon(QIcon(QPixmap(":/images/casesensitivity.png")));
+    findCaseSensitivity_toolbutton->setToolTip("Check to make case sensetive");
+    //findCaseSensitivity_toolbutton->setChecked(true);
+    //tools_layout->addWidget(expandAll_Checkbox,0,Qt::AlignLeft);
+    toolbar->addWidget(expandAll_Checkbox);
+    toolbar->addSeparator();
+    toolbar->addWidget(find_lineEdit);
+    toolbar->addWidget(findPrevious_toolbutton);
+    toolbar->addWidget(findNext_toolbutton);
+    toolbar->addWidget(findCaseSensitivity_toolbutton);
+    toolbar->addSeparator();
+
+    spacer = new QWidget();
+    spacer->setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Preferred);
+    toolbar->addWidget(spacer);
+    toolbar->addWidget(sortObj_toolButton);
+
+    tools_layout->addWidget(toolbar,0,0);
+
+
+    currentFindText=find_lineEdit->text();
+    currentFindIndexId=-1;
+
+    browse_groupBox=new QGroupBox(treeview_groupbox);
+    browse_layout=new QHBoxLayout(browse_groupBox);
+    browse_layout->setContentsMargins(0,0,0,0);
+    filePath_lineEdit=new QLineEdit(browse_groupBox);
+    filePath_lineEdit->setPlaceholderText(tr("Select file or use URL to load json data"));
+    filePath_lineEdit->setToolTip(tr("Select file or use full path/URL and hit enter to load json data"));
+    browse_toolButton=new QToolButton(browse_groupBox);
+    browse_toolButton->setText(tr("..."));
+    //filePath_lineEdit->setStyleSheet("border: 2");
+    qDebug()<<"treeview_layout adding widgets";
+    browse_layout->addWidget(filePath_lineEdit,1);
+    browse_layout->addWidget(browse_toolButton,0);
+    browse_groupBox->setLayout(browse_layout);
+    treeview_layout->addWidget(browse_groupBox,0);
+
+    //treeview_layout->addWidget(expandAll_Checkbox,0,Qt::AlignLeft);
+    treeview_layout->addLayout(tools_layout);
+    treeview_layout->addWidget(treeview);
+    treeview_layout->addWidget(viewjson_plaintext);
+    treeview_layout->addWidget(showjson_pushbutton);
+
+
+    qDebug()<<"treeview size";
+    treeview->resizeColumnToContents(0);
+    treeview->resizeColumnToContents(1);
+    treeview->resizeColumnToContents(2);
+    //treeview->setColumnWidth(2,300);
+    treeview->autoScrollMargin();
+    treeview->setAlternatingRowColors(true);
+    treeview->setAnimated(true);
+    treeview->setRootIsDecorated(true);
+
+
+    //treeview->setMinimumSize(500,500);
+
+    //read treeview stylesheet file from app resources
+    QFile file(":/qss/treeview.qss");
+    if(file.open(QIODevice::ReadOnly))
+        {
+            QString styleSheet = file.readAll();
+            file.close();
+            //apply stylesheet to treeview
+            treeview->setStyleSheet(styleSheet);
+        }
+    treeview->ensurePolished();
+    treeview->setContextMenuPolicy(Qt::CustomContextMenu);
+
+
+    qDebug()<<"obj_layout add widget treeview_groupbox";
+    obj_layout->addWidget(treeview_groupbox);
+    qDebug()<<"parent->setLayout(obj_layout)";
+    parent->setLayout(obj_layout);
+    //connect right click(context menu) signal/slot
+    //connect(treeview, SIGNAL(customContextMenuRequested(const QPoint&)),this, SLOT(ShowContextMenu(const QPoint&)));
+    connect(treeview, SIGNAL(expanded(const QModelIndex& )),this, SLOT(on_treeview_item_expanded()));
+    connect(expandAll_Checkbox, SIGNAL(stateChanged(int)), this, SLOT(on_expandAll_checkbox_marked()));
+    connect(browse_toolButton,SIGNAL(clicked()),this,SLOT(on_browse_toolButton_clicked()));
+    connect(sortObj_toolButton,SIGNAL(clicked()),this,SLOT(on_sortObj_toolButton_clicked()));
+    connect(filePath_lineEdit,SIGNAL(returnPressed()),this,SLOT(openJsonFile()));
+    connect(showjson_pushbutton,SIGNAL(clicked()),this,SLOT(on_showjson_pushbutton_clicked()));
+    connect(find_lineEdit,SIGNAL(returnPressed()),this,SLOT(findText()));
+    connect(find_lineEdit,SIGNAL(textChanged(QString)),this,SLOT(on_find_lineEdit_textChanged(QString)));
+    connect(findNext_toolbutton,SIGNAL(clicked()),this,SLOT(on_findNext_toolbutton_clicked()));
+    connect(findPrevious_toolbutton,SIGNAL(clicked()),this,SLOT(on_findPrevious_toolbutton_clicked()));
+    connect(findCaseSensitivity_toolbutton,SIGNAL(clicked()),this,SLOT(on_findCaseSensitivity_toolbutton_clicked()));
+    connect(model,SIGNAL(dataUpdated()),this,SLOT(on_model_dataUpdated()));
+
+
+    qDebug()<<"parent->setLayout(obj_layout) END";
+
+}
+
+QJsonContainer::~QJsonContainer()
+{
+    model->deleteLater();
+    treeview->deleteLater();
+    expandAll_Checkbox->deleteLater();
+    browse_groupBox->deleteLater();
+    filePath_lineEdit->deleteLater();
+    browse_toolButton->deleteLater();
+    browse_layout->deleteLater();
+    treeview_layout->deleteLater();
+    treeview_groupbox->deleteLater();
+}
+
+void QJsonContainer::findText()
+{
+    //viewjson_plaintext->moveCursor(QTextCursor::Start);
+    if(viewjson_plaintext->isVisible())
+        {
+        //ignore search case if button not pressed
+            if(!findCaseSensitivity_toolbutton->isChecked())
+            {
+                viewjson_plaintext->find(find_lineEdit->text());
+            }
+            else
+            {
+                viewjson_plaintext->find(find_lineEdit->text(),QTextDocument::FindCaseSensitively);
+            }
+        }
+    else
+        {
+            //works all values to stringlist
+            //QStringList strings = extractStringsFromModel(model, QModelIndex());
+            //QModelIndex idx=treeview->currentIndex();
+            //QStringList strings = extractStringsFromModel(model, idx);
+
+            //qDebug()<<"##################"<<strings;
+            findTextJsonIndexHandler(true);
+
+        }
+}
+
+void QJsonContainer::on_findNext_toolbutton_clicked()
+{
+    findText();
+}
+
+void QJsonContainer::on_findPrevious_toolbutton_clicked()
+{
+    if(viewjson_plaintext->isVisible())
+        {
+
+            if(!findCaseSensitivity_toolbutton->isChecked())
+            {
+                viewjson_plaintext->find(find_lineEdit->text(),QTextDocument::FindBackward);
+            }
+            else
+            {
+                viewjson_plaintext->find(find_lineEdit->text(),QTextDocument::FindBackward | QTextDocument::FindCaseSensitively);
+            }
+        }
+    else
+        {
+            findTextJsonIndexHandler(false);
+        }
+}
+
+void QJsonContainer::on_findCaseSensitivity_toolbutton_clicked()
+{
+    currentFindIndexesList.clear();
+    currentFindText=find_lineEdit->text();
+    currentFindIndexesList=findModelText(model, QModelIndex());
+    currentFindIndexId=-1;
+}
+
+/* Move trough json items that contain text
+ * Very stupid logic but it works
+ * input bool value:
+ *      true - forward;
+ *      false - backward;
+ *
+ *  TODO: make search cursor moving start from selection
+ */
+void QJsonContainer::findTextJsonIndexHandler(bool direction)
+{
+
+    if(currentFindText.isEmpty() || currentFindText!=find_lineEdit->text())
+        {
+            currentFindIndexesList.clear();
+            currentFindText=find_lineEdit->text();
+            currentFindIndexesList=findModelText(model, QModelIndex());
+            currentFindIndexId=-1;
+            qDebug()<<"##################"<<currentFindIndexesList;
+        }
+//QList<QModelIndex> tempList=currentFindIndexesList;
+//        if(!direction)
+//        {
+//            for(int k = 0; k < (tempList.size()/2); k++) tempList.swap(k,tempList.size()-(1+k));
+//        }
+    if(currentFindIndexesList.count()>0 && currentFindIndexId<currentFindIndexesList.count()-1 && direction)
+        {
+            currentFindIndexId++;
+        }
+    else if(currentFindIndexesList.count()>0 && currentFindIndexId>0 && currentFindIndexId<=currentFindIndexesList.count()-1 && !direction)
+        {
+            currentFindIndexId--;
+        }
+
+    else if(currentFindIndexesList.count()>0 && (currentFindIndexId==currentFindIndexesList.count()-1 || currentFindIndexId==0))
+        {
+            QRect widgetRect = treeview->visualRect(currentFindIndexesList[currentFindIndexId]);
+            QToolTip::showText( treeview->mapToGlobal( QPoint(widgetRect.center().x(),widgetRect.center().y()) ), (!direction)?tr("The last match! Next item will be from the end"):tr("The last match! Next item will be from the start"),treeview,QRect(100, 200, 11, 16),3000 );
+            currentFindIndexId=-1;
+        }
+    else if(currentFindIndexesList.count()>0 && currentFindIndexId==-1 && !direction)
+        {
+            currentFindIndexId=currentFindIndexesList.count()-1;
+        }
+    if(currentFindIndexesList.count()==0)
+    {
+        QRect widgetRect = find_lineEdit->contentsRect();
+        QToolTip::showText( find_lineEdit->mapToGlobal( QPoint(widgetRect.center().x(),widgetRect.center().y()) ), tr("<b><font \"color\"=red>Text Not Found!</font></b>"),0,QRect(100, 200, 11, 16),3000 );
+    }
+    if(currentFindIndexId>=0)
+        {
+            treeview->setCurrentIndex(currentFindIndexesList[currentFindIndexId]);
+        }
+}
+
+void QJsonContainer::setBrowseVisible(bool state)
+{
+    browse_groupBox->setVisible(state);
+}
+
+void QJsonContainer::on_showjson_pushbutton_clicked()
+{
+    if(viewjson_plaintext->isVisible())
+        {
+            viewjson_plaintext->setVisible(false);
+            treeview->setVisible(true);
+            loadJson(viewjson_plaintext->toPlainText());
+            showjson_pushbutton->setText(tr("Show Json Text"));
+        }
+    else
+        {
+            viewjson_plaintext->setVisible(true);
+            treeview->setVisible(false);
+            showjson_pushbutton->setText(tr("Show Json View"));
+        }
+    emit jsonUpdated();
+}
+
+void QJsonContainer::on_browse_toolButton_clicked()
+{
+    QString fileName = QFileDialog::getOpenFileName(this, tr("Open File"),"",tr("Files (*.json *.jsn *.txt);;All Files (*)"));
+    filePath_lineEdit->setText(fileName);
+    openJsonFile();
+
+}
+
+void QJsonContainer::openJsonFile()
+{
+    if(!filePath_lineEdit->text().contains("http://",Qt::CaseInsensitive) && !filePath_lineEdit->text().contains("https://",Qt::CaseInsensitive))
+        {
+            qDebug()<<"reloading file";
+            QFile file(filePath_lineEdit->text());
+            if(file.open(QIODevice::ReadOnly))
+                {
+                    QString data = file.readAll();
+                    file.close();
+                    loadJson(data);
+                }
+        }
+    else
+        {
+            qDebug()<<"downloading";
+            getData();
+        }
+    emit sOpenJsonFile();
+}
+
+void QJsonContainer::loadJson(QJsonDocument data)
+{
+    QString datastr=data.toJson();
+    viewjson_plaintext->setPlainText((QJsonDocument::fromJson(datastr.toUtf8())).toJson(QJsonDocument::Indented));
+    model->loadJson(datastr.toUtf8());
+    on_expandAll_checkbox_marked();
+    //treeview->setColumnWidth(2,300);
+}
+
+void QJsonContainer::loadJson(QString data)
+{
+    viewjson_plaintext->setPlainText((QJsonDocument::fromJson(data.toUtf8())).toJson(QJsonDocument::Indented));
+    model->loadJson(data.toUtf8());
+    on_expandAll_checkbox_marked();
+    //treeview->setColumnWidth(2,300);
+}
+
+void QJsonContainer::on_expandAll_checkbox_marked()
+{
+//qDebug()<<"marked";
+    if (expandAll_Checkbox->isChecked())
+        {
+            treeview->expandAll();
+            treeview->resizeColumnToContents(0);
+            treeview->resizeColumnToContents(1);
+            treeview->resizeColumnToContents(2);
+            //treeview->setColumnWidth(2,300);
+            //treeview->viewport()->setBackgroundRole(QPalette::Dark);
+            //qDebug()<<treeview->indexAt(QPoint(50,50)).;
+        }
+    else
+        {
+            treeview->collapseAll();
+        }
+}
+
+void QJsonContainer::expandIt()
+{
+    expandAll_Checkbox->setChecked(true);
+    on_expandAll_checkbox_marked();
+}
+
+void QJsonContainer::on_treeview_item_expanded()
+{
+    //qDebug()<<"expanded";
+    if(!expandAll_Checkbox->isChecked())
+        {
+            QTreeView *treeviewcall = (QTreeView *)sender();
+            treeviewcall->resizeColumnToContents(0);
+            treeviewcall->resizeColumnToContents(1);
+            treeviewcall->resizeColumnToContents(2);
+            //treeviewcall->setColumnWidth(2,300);
+        }
+}
+
+QJsonModel* QJsonContainer::getJsonModel()
+{
+    return model;
+}
+
+QTreeView* QJsonContainer::getTreeView()
+{
+    return treeview;
+}
+
+void QJsonContainer::reInitModel()
+{
+    loadJson(viewjson_plaintext->toPlainText().toUtf8());
+}
+
+//sort arrays inside of objects
+QJsonDocument QJsonContainer::sortObjectArrays(QJsonDocument data)
+{
+    QJsonDocument resultData=data;
+    if(data.isObject())
+    {
+        QJsonObject jsonObj=data.object();
+        resultData=QJsonDocument::fromVariant(sortObjectArraysGrabObject(jsonObj).toVariantMap());
+    }
+    else
+    {
+        QJsonArray jsonArr=data.array();
+        resultData=QJsonDocument::fromVariant(sortObjectArraysGrabArray(jsonArr).toVariantList());
+    }
+    return resultData;
+}
+//Count "weight of string" or it's rather some kind of hashcode
+//from my point of view it's almost unique and possible to recognize identical string
+//"weight of string"="sum charachters code numbers" * "string length"
+int QJsonContainer::countStringWeight(QString inStr)
+{
+    int total=0;
+    for(int i=0; i <= inStr.length()-1; i++)
+        {
+            QChar ch = inStr.at(i);
+
+            total=total+ch.unicode();
+        }
+    total=total*inStr.length();
+    //qDebug()<<total;
+    return total;
+}
+//condition how to sort objects in array
+bool QJsonContainer::wayToSort(const QJsonValue &v1,const QJsonValue &v2)
+{
+    // qDebug()<<"call";
+    if(v1.isObject() && v2.isObject())
+        {
+            return countStringWeight(QJsonDocument(v1.toObject()).toJson()) < countStringWeight(QJsonDocument(v2.toObject()).toJson());
+        }
+    else if(v1.isDouble() && v2.isDouble())
+        {
+            //qDebug()<<v1<<" "<<v2;
+            return v1.toDouble()<v2.toDouble();
+        }
+    return -1;
+}
+//sort array
+//need to apply patch to qt https://codereview.qt-project.org/#/c/108352/
+QJsonArray QJsonContainer::sortObjectArraysGrabArray(QJsonArray data)
+{
+    int arrayId=0;
+    QJsonArray resultData=data;
+    if(data.at(0).isObject())
+        {
+            //qDebug()<<data;
+            //qDebug()<<data.count();
+           //  std::sort(data.begin(), data.end(), wayToSort);
+
+            //qDebug()<<data;
+
+        }
+    else if(data.at(0).isDouble())
+        {
+            //qDebug()<<data;
+            //qDebug()<<data.count();
+            // std::sort(data.begin(), data.end(),wayToSort);
+            //qDebug()<<data;
+
+        }
+    resultData=data;
+    arrayId=0;
+    foreach (const QJsonValue & value, resultData)
+        {
+            if (value.isObject())
+                {
+                    //qDebug() << "Object" << value.toString();
+                    resultData.removeAt(arrayId);
+                    resultData.insert(arrayId,sortObjectArraysGrabObject(value.toObject()));
+                }
+
+            arrayId++;
+        }
+    //qDebug()<<resultData;
+    return resultData;
+}
+
+QJsonObject QJsonContainer::sortObjectArraysGrabObject(QJsonObject data)
+{
+    QJsonObject resultData=data;
+    for(QJsonObject::const_iterator iter = data.begin(); iter != data.end(); ++iter)
+        {
+            if (iter.value().isArray())
+                {
+                    //qDebug() << iter.key()  << "Array" << iter.value().toString();
+                    resultData.remove(iter.key());
+                    resultData.insert(iter.key(),sortObjectArraysGrabArray(iter.value().toArray()));
+                }
+            else if (iter.value().isObject())
+                {
+                    //qDebug() << iter.key() << "Object" << iter.value().toString();
+                    resultData.remove(iter.key());
+                    resultData.insert(iter.key(),sortObjectArraysGrabObject(iter.value().toObject()));
+
+                }
+        }
+    return resultData;
+}
+
+
+void QJsonContainer::on_sortObj_toolButton_clicked()
+{
+    viewjson_plaintext->setPlainText(sortObjectArrays(QJsonDocument::fromJson((viewjson_plaintext->toPlainText().toUtf8()))).toJson());
+    reInitModel();
+}
+
+QByteArray QJsonContainer::gUncompress(const QByteArray &data)
+{
+    qDebug()<<"Uncompressing...";
+//    if (data.size() <= 4)
+//        {
+//            qWarning("gUncompress: Input data is truncated");
+//            return QByteArray();
+//        }
+
+    QByteArray result;
+
+//    int ret;
+//    z_stream strm;
+//    static const int CHUNK_SIZE = 1024;
+//    char out[CHUNK_SIZE];
+
+//    /* allocate inflate state */
+//    strm.zalloc = Z_NULL;
+//    strm.zfree = Z_NULL;
+//    strm.opaque = Z_NULL;
+//    strm.avail_in = data.size();
+//    strm.next_in = (Bytef*)(data.data());
+
+//    ret = inflateInit2(&strm, 15 +  32); // gzip decoding
+//    if (ret != Z_OK)
+//        return QByteArray();
+
+//    // run inflate()
+//    do
+//        {
+//            strm.avail_out = CHUNK_SIZE;
+//            strm.next_out = (Bytef*)(out);
+
+//            ret = inflate(&strm, Z_NO_FLUSH);
+//            Q_ASSERT(ret != Z_STREAM_ERROR);  // state not clobbered
+
+//            switch (ret)
+//                {
+//                case Z_NEED_DICT:
+//                    ret = Z_DATA_ERROR;     // and fall through
+//                case Z_DATA_ERROR:
+//                case Z_MEM_ERROR:
+//                    (void)inflateEnd(&strm);
+//                    return QByteArray();
+//                }
+
+//            result.append(out, CHUNK_SIZE - strm.avail_out);
+//        }
+//    while (strm.avail_out == 0);
+
+//    // clean up and return
+//    inflateEnd(&strm);
+    return result;
+}
+
+void QJsonContainer::getData()
+{
+    qDebug()<<"Starting get";
+    QUrl serviceUrl = QUrl(filePath_lineEdit->text());
+    loadJson("{\"status\":\"Starting Get\",\"host\":\"" + serviceUrl.url() + "\"}");
+
+    QNetworkAccessManager *networkManager = new QNetworkAccessManager(this);
+    connect(networkManager, SIGNAL(finished(QNetworkReply*)), this, SLOT(serviceGetDataRequestFinished(QNetworkReply*)));
+    QNetworkRequest request(serviceUrl);
+    if((serviceUrl.toString()).contains("https",Qt::CaseInsensitive))
+        {
+            QSslConfiguration SslConfiguration(QSslConfiguration::defaultConfiguration());
+            SslConfiguration.setProtocol(QSsl::AnyProtocol);
+            request.setSslConfiguration(SslConfiguration);
+        }
+    request.setRawHeader("Accept-Language", "en-US,en;q=0.8");
+    request.setRawHeader("Cache-Control", "no-cache");
+    request.setRawHeader("Accept-Encoding", "gzip, deflate");
+    loadJson("{\"status\":\"Sending Get\",\"host\":\"" + serviceUrl.url() + "\"}");
+    QNetworkReply *reply=networkManager->get(request);
+    Q_UNUSED(reply);
+}
+
+void QJsonContainer::serviceGetDataRequestFinished(QNetworkReply* reply)
+{
+    qDebug()<<"Reply Received";
+    QString url=reply->url().toString();
+    loadJson("{\"status\":\"Reply received\",\"host\":\"" + url + "\"}");
+    QObject *networkManager = sender();
+    networkManager->deleteLater();
+    reply->deleteLater();
+    if(reply->error() == QNetworkReply::NoError)
+        {
+            QByteArray bytes = reply->readAll();
+            if(reply->rawHeader("Content-Encoding")==QString("gzip"))
+                {
+                    bytes=gUncompress(bytes);
+                }
+
+            qDebug()<<bytes;
+            loadJson(QString(bytes));
+        }
+    else
+        {
+            qDebug()<<"Error";
+            qDebug()<<reply->error();
+            qDebug()<<reply->errorString();
+            loadJson("{\"status\":\"Error\",\"host\":\"" + url + "\",\"Error Description\":\"" + reply->errorString() + "\"}");
+        }
+}
+
+QStringList QJsonContainer::extractStringsFromModel(QJsonModel *model, const QModelIndex &parent)
+{
+    QStringList retval;
+
+
+    int rowCount = model->rowCount(parent);
+
+    for(int i = 0; i < rowCount; ++i)
+        {
+            QModelIndex idx0 = model->index(i, 0, parent);
+            QModelIndex idx1 = model->index(i, 1, parent);
+            QModelIndex idx2 = model->index(i, 2, parent);
+            qDebug()<<idx0.data(Qt::DisplayRole).toString()<<idx1.data(Qt::DisplayRole).toString()<<idx2.data(Qt::DisplayRole).toString();
+            qDebug()<<static_cast<QJsonTreeItem*>(idx0.internalPointer())->typeName();
+            //QJsonTreeItem *item = static_cast<QJsonTreeItem*>(idx0.internalPointer());
+
+            if(idx0.isValid())
+                {
+                    retval << idx0.data(Qt::DisplayRole).toString() +QString("|")+idx2.data(Qt::DisplayRole).toString();
+                    //qDebug()<<idx0.data(Qt::DisplayRole).toString();
+                    retval << extractStringsFromModel(model, idx0);
+                }
+        }
+
+    return retval;
+}
+
+QList<QModelIndex> QJsonContainer::findModelText(QJsonModel *model, const QModelIndex &parent)
+{
+    QList<QModelIndex> retindex;
+
+    QString stringToSearch=find_lineEdit->text();
+    if(!findCaseSensitivity_toolbutton->isChecked())
+    {
+        stringToSearch=stringToSearch.toLower();
+    }
+
+
+    int rowCount = model->rowCount(parent);
+
+    for(int i = 0; i < rowCount; ++i)
+        {
+            QModelIndex idx0 = model->index(i, 0, parent);
+            QModelIndex idx1 = model->index(i, 1, parent);
+            QModelIndex idx2 = model->index(i, 2, parent);
+            qDebug()<<idx0.data(Qt::DisplayRole).toString()<<idx1.data(Qt::DisplayRole).toString()<<idx2.data(Qt::DisplayRole).toString();
+            qDebug()<<static_cast<QJsonTreeItem*>(idx0.internalPointer())->typeName();
+            //QJsonTreeItem *item = static_cast<QJsonTreeItem*>(idx0.internalPointer());
+
+            if(idx0.isValid())
+                {
+                    //retval << idx0.data(Qt::DisplayRole).toString() +QString("|")+idx2.data(Qt::DisplayRole).toString();
+                    qDebug()<<idx0.data(Qt::DisplayRole).toString();
+                    //retval << extractStringsFromModel(model, idx0);
+                    QString itemText=QString(idx0.data(Qt::DisplayRole).toString() +QString("|")+idx2.data(Qt::DisplayRole).toString());
+                    if(!findCaseSensitivity_toolbutton->isChecked())
+                    {
+                        itemText=itemText.toLower();
+                    }
+                    if(itemText.contains(stringToSearch))
+                        {
+                            retindex<<idx0;
+
+                        }
+                    retindex<<findModelText(model, idx0);
+                }
+        }
+
+    return retindex;
+}
+
+void QJsonContainer::on_find_lineEdit_textChanged(QString text)
+{
+    qDebug()<<"serach text has been changed: "<<text;
+    resetCurrentFind();
+
+}
+
+void QJsonContainer::resetCurrentFind()
+{
+    currentFindIndexesList.clear();
+    currentFindIndexId=-1;
+    currentFindText="";
+}
+
+void QJsonContainer::on_model_dataUpdated()
+{
+    qDebug()<<"model has been changed";
+    resetCurrentFind();
+}
diff --git a/src/qjsoncontainer.h b/src/qjsoncontainer.h
new file mode 100644
index 0000000..7cbdb77
--- /dev/null
+++ b/src/qjsoncontainer.h
@@ -0,0 +1,107 @@
+/* Author: Yuriy Kuzin
+ */
+#ifndef QJSONCONTAINER_H
+#define QJSONCONTAINER_H
+
+#include <QObject>
+#include <QWidget>
+#include "qjsonmodel.h"
+#include <QTreeView>
+#include <QCheckBox>
+#include <QVBoxLayout>
+#include <QGroupBox>
+#include <QBoxLayout>
+#include <QLineEdit>
+#include <QToolButton>
+#include <QFileDialog>
+#include <QPlainTextEdit>
+#include <QPushButton>
+#include <QToolTip>
+#include <QToolBar>
+
+#include <QNetworkAccessManager>
+#include <QUrl>
+#include <QNetworkRequest>
+#include <QNetworkProxy>
+#include <QNetworkReply>
+#include <QSslConfiguration>
+#include <QSsl>
+
+class QJsonContainer : public QWidget
+{
+Q_OBJECT
+public:
+    explicit QJsonContainer(QWidget *parent=0);
+    ~QJsonContainer();
+
+    QJsonModel *model;
+    QTreeView *treeview;
+    QPlainTextEdit *viewjson_plaintext;
+    QCheckBox *expandAll_Checkbox;
+    void loadJson(QJsonDocument data);
+    void loadJson(QString data);
+    QTreeView* getTreeView();
+    QJsonModel* getJsonModel();
+    QVBoxLayout *treeview_layout;
+    QGroupBox *treeview_groupbox;
+    QVBoxLayout *obj_layout;
+    void expandIt();
+    QGroupBox *browse_groupBox;
+    QLineEdit *filePath_lineEdit;
+    QLineEdit *find_lineEdit;
+    QToolButton* browse_toolButton;
+    QToolButton* sortObj_toolButton;
+    QGridLayout* tools_layout;
+    QToolBar *toolbar;
+    QWidget *spacer;
+    QHBoxLayout *browse_layout;
+    void setBrowseVisible(bool state);
+    QPushButton *showjson_pushbutton;
+    QToolButton *findNext_toolbutton;
+    QToolButton *findPrevious_toolbutton;
+    QToolButton *findCaseSensitivity_toolbutton;
+    void reInitModel();
+    QStringList extractStringsFromModel(QJsonModel *model, const QModelIndex &parent);
+    QList<QModelIndex> findModelText(QJsonModel *model, const QModelIndex &parent);
+    QJsonDocument sortObjectArrays(QJsonDocument data);
+    QJsonArray sortObjectArraysGrabArray(QJsonArray data);
+    QJsonObject sortObjectArraysGrabObject(QJsonObject data);
+    static int countStringWeight(QString inStr);
+    static bool wayToSort(const QJsonValue &v1, const QJsonValue &v2);
+    void getData();
+
+private:
+        QByteArray gUncompress(const QByteArray &data);
+        //variables to handle serach nodes in tree
+        QList<QModelIndex> currentFindIndexesList;
+        QString currentFindText;
+        int currentFindIndexId;
+        void resetCurrentFind();
+        void findTextJsonIndexHandler(bool direction);
+
+signals:
+   void sOpenJsonFile();
+   void jsonUpdated();
+
+
+private slots:
+    void on_expandAll_checkbox_marked();
+    void on_treeview_item_expanded();
+    void on_browse_toolButton_clicked();
+    void on_showjson_pushbutton_clicked();
+    void on_sortObj_toolButton_clicked();
+    void on_findNext_toolbutton_clicked();
+    void on_findPrevious_toolbutton_clicked();
+    void on_findCaseSensitivity_toolbutton_clicked();
+    void openJsonFile();
+    void serviceGetDataRequestFinished(QNetworkReply* reply);
+    void on_find_lineEdit_textChanged(QString text);
+    void on_model_dataUpdated();
+public slots:
+    void findText();
+
+};
+
+
+
+#endif // QJSONCONTAINER_H
diff --git a/src/qjsonitem.cpp b/src/qjsonitem.cpp
new file mode 100644
index 0000000..7a3933b
--- /dev/null
+++ b/src/qjsonitem.cpp
@@ -0,0 +1,214 @@
+/***********************************************
+    Copyright (C) 2014  Schutz Sacha
+    This file is part of QJsonModel (https://github.com/dridk/QJsonmodel).
+
+    QJsonModel is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    QJsonModel is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with QJsonModel.  If not, see <http://www.gnu.org/licenses/>.
+
+**********************************************/
+
+/*
+ * Modified by Yuriy Kuzin
+ * Updated to support diff
+ *
+ */
+
+#include "qjsonitem.h"
+
+QJsonTreeItem::QJsonTreeItem(QJsonTreeItem *parent)
+{
+
+    mParent = parent;
+
+}
+
+QJsonTreeItem::~QJsonTreeItem()
+{
+    qDeleteAll(mChilds);
+}
+
+void QJsonTreeItem::appendChild(QJsonTreeItem *item)
+{
+    mChilds.append(item);
+}
+
+QJsonTreeItem *QJsonTreeItem::child(int row)
+{
+    return mChilds.value(row);
+}
+
+QJsonTreeItem *QJsonTreeItem::parent()
+{
+    return mParent;
+}
+
+int QJsonTreeItem::childCount() const
+{
+    return mChilds.count();
+}
+
+int QJsonTreeItem::row() const
+{
+    if (mParent)
+        return mParent->mChilds.indexOf(const_cast<QJsonTreeItem*>(this));
+
+    return 0;
+}
+
+void QJsonTreeItem::setKey(const QString &key)
+{
+    mKey = key;
+}
+
+void QJsonTreeItem::setValue(const QString &value)
+{
+    mValue = value;
+}
+
+void QJsonTreeItem::setToolTip(const QString &toolTip)
+{
+    mToolTip = toolTip;
+}
+
+void QJsonTreeItem::setType(const QJsonValue::Type &type)
+{
+    mType = type;
+}
+/* Posibility to set/remember index from another model
+ * to relate them and perform selection in diff view
+ */
+void QJsonTreeItem::setIdxRelation(QModelIndex idxPointer)
+{
+    mIdxRelation = idxPointer;
+}
+
+/* set color of an item
+ */
+void QJsonTreeItem::setColor(const QColor &color)
+{
+        mColor = color;
+}
+
+/* Get index of relation from another model
+ * so you can select again it's for diff purposes
+ */
+QModelIndex QJsonTreeItem::idxRelation()
+{
+    return mIdxRelation;
+}
+
+QString QJsonTreeItem::key() const
+{
+    return mKey;
+}
+
+QString QJsonTreeItem::value() const
+{
+    return mValue;
+}
+
+QString QJsonTreeItem::toolTip() const
+{
+    return mToolTip;
+}
+
+/* get current color of item
+ */
+QColor QJsonTreeItem::color() const
+{
+    return mColor;
+}
+
+QJsonValue::Type QJsonTreeItem::type() const
+{
+    return mType;
+}
+/* Get string type name of json item
+ */
+QString QJsonTreeItem::typeName() const
+{
+    //return QVariant::typeToName(mType);
+    if (mType==QJsonValue::Array)
+    {
+        return QString("Array");
+    }
+    else if (mType==QJsonValue::String)
+    {
+        return QString("String");
+    }
+    else if (mType==QJsonValue::Bool)
+    {
+        return QString("Bool");
+    }
+    else if (mType==QJsonValue::Double)
+    {
+        return QString("Double");
+    }
+    else if (mType==QJsonValue::Null)
+    {
+        return QString("Null");
+    }
+    else if (mType==QJsonValue::Object)
+    {
+        return QString("Object");
+    }
+    else if (mType==QJsonValue::Undefined)
+    {
+        return QString("Undefined");
+    }
+   qDebug()<<"Fatal error wrong json type";
+   return QString("Fatal");
+}
+
+QJsonTreeItem* QJsonTreeItem::load(const QJsonValue& value, QJsonTreeItem* parent)
+{
+    QJsonTreeItem * rootItem = new QJsonTreeItem(parent);
+    rootItem->setKey("root");
+
+    if ( value.isObject())
+    {
+
+        //Get all QJsonValue childs
+        foreach (QString key , value.toObject().keys()){
+            QJsonValue v = value.toObject().value(key);
+            QJsonTreeItem * child = load(v,rootItem);
+            child->setKey(key);
+            child->setType(v.type());
+            rootItem->appendChild(child);
+
+        }
+
+    }
+
+    else if ( value.isArray())
+    {
+        //Get all QJsonValue childs
+        int index = 0;
+        foreach (QJsonValue v , value.toArray()){
+
+            QJsonTreeItem * child = load(v,rootItem);
+            child->setKey(QString::number(index));
+            child->setType(v.type());
+            rootItem->appendChild(child);
+            ++index;
+        }
+    }
+    else
+    {
+        rootItem->setValue(value.toVariant().toString());
+        rootItem->setType(value.type());
+    }
+
+    return rootItem;
+}
+
diff --git a/src/qjsonitem.h b/src/qjsonitem.h
new file mode 100644
index 0000000..cb62038
--- /dev/null
+++ b/src/qjsonitem.h
@@ -0,0 +1,63 @@
+/*
+ * Creator Schutz Sacha
+ * Modified by Yuriy Kuzin
+ * Updated to support diff
+ *
+ */
+
+#ifndef JSONITEM_H
+#define JSONITEM_H
+#include <QtCore>
+#include <QJsonValue>
+#include <QJsonArray>
+#include <QJsonObject>
+#include <QVariant>
+#include <QStyleOptionViewItem>
+#include <QPainter>
+class QJsonTreeItem
+{
+public:
+    QJsonTreeItem(QJsonTreeItem * parent = 0);
+    ~QJsonTreeItem();
+    void appendChild(QJsonTreeItem * item);
+    QJsonTreeItem *child(int row);
+    QJsonTreeItem *parent();
+    int childCount() const;
+    int row() const;
+    void setKey(const QString& key);
+    void setValue(const QString& value);
+    void setToolTip(const QString& toolTip);
+    void setType(const QJsonValue::Type& type);
+    void setColor(const QColor& color);
+    void setIdxRelation(QModelIndex idxPointer);
+    QString key() const;
+    QString value() const;
+    QJsonValue::Type type() const;
+    QString typeName() const;
+    QString toolTip() const;
+    QColor color() const;
+    QModelIndex idxRelation();
+
+    static QJsonTreeItem* load(const QJsonValue& value, QJsonTreeItem * parent = 0);
+
+protected:
+
+
+private:
+    QString mKey;
+    QString mTypeName;
+    QString mValue;
+    QString mToolTip;
+    QJsonValue::Type mType;
+    QColor mColor;
+    QModelIndex mIdxRelation;
+
+    QList<QJsonTreeItem*> mChilds;
+    QJsonTreeItem * mParent;
+
+
+};
+
+//Q_DECLARE_METATYPE(QJsonTreeItem)
+
+#endif // JSONITEM_H
diff --git a/src/qjsonmodel.cpp b/src/qjsonmodel.cpp
new file mode 100644
index 0000000..8bb0eab
--- /dev/null
+++ b/src/qjsonmodel.cpp
@@ -0,0 +1,257 @@
+/***********************************************
+    Copyright (C) 2014  Schutz Sacha
+    This file is part of QJsonModel (https://github.com/dridk/QJsonmodel).
+
+    QJsonModel is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    QJsonModel is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with QJsonModel.  If not, see <http://www.gnu.org/licenses/>.
+
+**********************************************/
+
+/*
+ * Modified by Yuriy Kuzin
+ * Updated to support diff
+ *
+ */
+
+#include "qjsonmodel.h"
+#include <QFile>
+#include <QDebug>
+#include <QJsonDocument>
+#include <QJsonObject>
+#include <QIcon>
+#include <QFont>
+
+QJsonModel::QJsonModel(QObject *parent) :
+    QAbstractItemModel(parent)
+{
+    mRootItem = new QJsonTreeItem;
+    mHeaders.append("Name");
+    mHeaders.append("Type");
+    mHeaders.append("Value");
+
+
+}
+
+QJsonModel::~QJsonModel()
+{
+    delete mRootItem;
+}
+
+/* maybe it's not really right place
+ * file opening inside model
+ * but for me it's normal
+ */
+bool QJsonModel::load(const QString &fileName)
+{
+    QFile file(fileName);
+    bool success = false;
+    if (file.open(QIODevice::ReadOnly)) {
+        success = load(&file);
+        file.close();
+    }
+    else success = false;
+
+    return success;
+}
+
+/* read everything from device
+ */
+bool QJsonModel::load(QIODevice *device)
+{
+    return loadJson(device->readAll());
+}
+
+/* Load json into model from text
+ * emit signal when new model loaded - dataUpdated()
+ * so it's possible to listen it
+ */
+bool QJsonModel::loadJson(const QByteArray &json)
+{
+    QJsonParseError parseError;
+        QJsonDocument mDocument=QJsonDocument::fromJson(json,&parseError);
+        if (parseError.error != QJsonParseError::NoError)
+        {
+            qDebug() << " QJsonParseError::NoError ";
+            beginResetModel();
+            delete mRootItem;
+            mRootItem = QJsonTreeItem::load(QJsonValue(QJsonDocument::fromJson((QString(
+                                                                                     "{\"Error\":\"") + QString(parseError.errorString() +
+                                                                                   "\",\"offset\":")+ QString::number(parseError.offset) +
+                                                                                    "}").toUtf8()).object()));
+            endResetModel();
+            emit dataUpdated();
+            return true;
+        }
+        if(!mDocument.isNull())
+        {
+            qDebug() << "!mDocument.isNull()";
+            beginResetModel();
+            delete mRootItem;
+            if(mDocument.isObject())
+            {
+                qDebug() << "mDocument.isObject()";
+                mRootItem = QJsonTreeItem::load(QJsonValue(mDocument.object()));
+            }
+            else
+            {
+                mRootItem = QJsonTreeItem::load(QJsonValue(mDocument.array()));
+            }
+            endResetModel();
+            emit dataUpdated();
+            return true;
+        }
+        else
+        {
+            qDebug()<<"Error!! in json";
+            emit dataUpdated();
+            return false;
+        }
+    emit dataUpdated();
+    return false;
+}
+
+
+QVariant QJsonModel::data(const QModelIndex &index, int role) const
+{
+
+    if (!index.isValid())
+        return QVariant();
+
+
+    QJsonTreeItem *item = static_cast<QJsonTreeItem*>(index.internalPointer());
+
+    if (role == Qt::BackgroundColorRole)
+    {
+        if(!item->color().isValid())
+        {
+            return QColor(Qt::white);
+        }
+        else
+        {
+            return item->color();
+        }
+    }
+
+    if (role==Qt::ToolTipRole)
+    {
+        return item->toolTip();
+    }
+
+    if ((role == Qt::DecorationRole) && (index.column() == 0)){
+
+        return mTypeIcons.value(item->type());
+    }
+
+    if (role == Qt::DisplayRole) {
+
+        if (index.column() == 0)
+            return QString("%1").arg(item->key());
+        if (index.column() == 1)
+        {
+            if (item->type()==QJsonValue::Array)
+            {
+                return QString("%1").arg(QString("Array") + QString("[") + QString::number(item->childCount()) + QString("]"));
+            }
+            else
+            {
+                return QString("%1").arg(item->typeName());
+            }
+        }
+
+        if (index.column() == 2)
+            return QString("%1").arg(item->value());
+    }
+
+
+
+    return QVariant();
+
+}
+
+QVariant QJsonModel::headerData(int section, Qt::Orientation orientation, int role) const
+{
+    if (role != Qt::DisplayRole)
+        return QVariant();
+
+    if (orientation == Qt::Horizontal) {
+
+        return mHeaders.value(section);
+    }
+    else
+        return QVariant();
+}
+
+QModelIndex QJsonModel::index(int row, int column, const QModelIndex &parent) const
+{
+    if (!hasIndex(row, column, parent))
+        return QModelIndex();
+
+    QJsonTreeItem *parentItem;
+
+    if (!parent.isValid())
+        parentItem = mRootItem;
+    else
+        parentItem = static_cast<QJsonTreeItem*>(parent.internalPointer());
+
+    QJsonTreeItem *childItem = parentItem->child(row);
+    if (childItem)
+        return createIndex(row, column, childItem);
+    else
+        return QModelIndex();
+}
+
+QModelIndex QJsonModel::parent(const QModelIndex &index) const
+{
+    if (!index.isValid())
+        return QModelIndex();
+
+    QJsonTreeItem *childItem = static_cast<QJsonTreeItem*>(index.internalPointer());
+    QJsonTreeItem *parentItem = childItem->parent();
+
+    if (parentItem == mRootItem)
+        return QModelIndex();
+
+    return createIndex(parentItem->row(), 0, parentItem);
+}
+
+QJsonTreeItem* QJsonModel::itemFromIndex(const QModelIndex &index) const
+{
+    return static_cast<QJsonTreeItem*>(index.internalPointer());
+}
+
+int QJsonModel::rowCount(const QModelIndex &parent) const
+{
+    QJsonTreeItem *parentItem;
+    if (parent.column() > 0)
+        return 0;
+
+    if (!parent.isValid())
+        parentItem = mRootItem;
+    else
+        parentItem = static_cast<QJsonTreeItem*>(parent.internalPointer());
+
+    return parentItem->childCount();
+}
+
+int QJsonModel::columnCount(const QModelIndex &parent) const
+{
+    Q_UNUSED(parent)
+    return 3;
+}
+
+void QJsonModel::setIcon(const QJsonValue::Type &type, const QIcon &icon)
+{
+    mTypeIcons.insert(type,icon);
+}
+
+
diff --git a/src/qjsonmodel.h b/src/qjsonmodel.h
new file mode 100644
index 0000000..f0fad52
--- /dev/null
+++ b/src/qjsonmodel.h
@@ -0,0 +1,53 @@
+/*
+ * Creator Schutz Sacha
+ * Modified by Yuriy Kuzin
+ * Updated to support diff
+ *
+ */
+
+#ifndef QJSONMODEL_H
+#define QJSONMODEL_H
+
+#include <QAbstractItemModel>
+#include "qjsonitem.h"
+#include <QJsonDocument>
+#include <QJsonObject>
+#include <QIcon>
+#include <QStyleOptionViewItem>
+#include <QPainter>
+#include <QStyledItemDelegate>
+
+class QJsonModel : public QAbstractItemModel
+{
+    Q_OBJECT
+public:
+    explicit QJsonModel(QObject *parent = 0);
+    ~QJsonModel();
+    bool load(const QString& fileName);
+    bool load(QIODevice * device);
+    bool loadJson(const QByteArray& json);
+    QVariant data(const QModelIndex &index, int role) const;
+    QVariant headerData(int section, Qt::Orientation orientation, int role) const;
+    QModelIndex index(int row, int column,const QModelIndex &parent = QModelIndex()) const;
+    QModelIndex parent(const QModelIndex &index) const;
+    int rowCount(const QModelIndex &parent = QModelIndex()) const;
+    int columnCount(const QModelIndex &parent = QModelIndex()) const;
+    QJsonTreeItem* itemFromIndex(const QModelIndex &index) const;
+    void setIcon(const QJsonValue::Type& type, const QIcon& icon);
+
+
+
+
+private:
+    QJsonTreeItem * mRootItem;
+    QJsonDocument mDocument;
+    QStringList mHeaders;
+    QHash<QJsonValue::Type, QIcon> mTypeIcons;
+
+signals:
+   void dataUpdated();
+
+
+};
+
+#endif // QJSONMODEL_H
diff --git a/src/resource.qrc b/src/resource.qrc
index 30d10fc..c096c92 100644
--- a/src/resource.qrc
+++ b/src/resource.qrc
@@ -28,6 +28,7 @@
         <file>png/document-open-recent-2_gray.png</file>
         <file>png/network-transmit-receive_connected.png</file>
         <file>png/network-transmit-receive_disconnected.png</file>
+        <file>png/store.png</file>
     </qresource>
     <qresource prefix="/icons">
         <file>png/face-glasses.png</file>
diff --git a/src/searchtablemodel.cpp b/src/searchtablemodel.cpp
index 0b7215a..d8d6537 100644
--- a/src/searchtablemodel.cpp
+++ b/src/searchtablemodel.cpp
@@ -187,7 +187,7 @@ QVariant SearchTableModel::data(const QModelIndex &index, int role) const
 
     if ( role == Qt::BackgroundRole ) {
         //always black
-        return QVariant(QBrush(QColor(255,255,255)));
+        return index.row() % 2 ? QVariant(QBrush(QColor(255,255,255))) : QVariant(QBrush(QColor(240,240,240))) ;
     }
 
 
diff --git a/src/settingsdialog.cpp b/src/settingsdialog.cpp
index 81eefba..d69247f 100644
--- a/src/settingsdialog.cpp
+++ b/src/settingsdialog.cpp
@@ -235,6 +235,7 @@ void SettingsDialog::writeDlg()
 
     /* table */
     ui->spinBoxFontSize->setValue(fontSize);
+    ui->spinBoxRowSize->setValue(rowSize);
 
     /* Time settings */
     ui->groupBoxAutomaticTimeSettings->setChecked(automaticTimeSettings);
@@ -365,7 +366,12 @@ void SettingsDialog::writeDlg()
     bool startup_minimized = settings->value("StartUpMinimized",false).toBool();
     ui->checkBoxStartUpMinimized->setChecked(startup_minimized);
 
-
+    ui->jsonCheck->setChecked( checkJSON?Qt::Checked:Qt::Unchecked );
+    if( checkJSON ){
+        ui->groupBoxArguments->setChecked(true);
+        showArguments = 1;
+        ui->spinBox_showArguments->setValue( showArguments );
+    }
 }
 
 void SettingsDialog::readDlg()
@@ -406,6 +412,7 @@ void SettingsDialog::readDlg()
 
     /* table */
     fontSize = ui->spinBoxFontSize->value();
+    rowSize = ui->spinBoxRowSize->value();
 
     /* Time settings */
     automaticTimeSettings = ( ui->groupBoxAutomaticTimeSettings->isChecked() == true ? 1:0);
@@ -446,6 +453,8 @@ void SettingsDialog::readDlg()
 
     bool startup_minimized = ui->checkBoxStartUpMinimized->isChecked();
     settings->setValue("StartUpMinimized",startup_minimized);
+
+    checkJSON = ( ui->jsonCheck->isChecked() == true ? 1:0);
 }
 
 void SettingsDialog::writeSettings(QMainWindow *mainwindow)
@@ -488,6 +497,7 @@ void SettingsDialog::writeSettings(QMainWindow *mainwindow)
 
     /* table */
     settings->setValue("startup/fontSize",fontSize);
+    settings->setValue("startup/rowSize", rowSize );
     settings->setValue("startup/automaticTimeSettings",automaticTimeSettings);
     settings->setValue("startup/automaticTimezoneFromDlt",automaticTimezoneFromDlt);
     settings->setValue("startup/utcOffset",utcOffset);
@@ -521,6 +531,8 @@ void SettingsDialog::writeSettings(QMainWindow *mainwindow)
     settings->setValue("startup/versionMajor", QString(PACKAGE_MAJOR_VERSION).toInt());
     settings->setValue("startup/versionMinor", QString(PACKAGE_MINOR_VERSION).toInt());
     settings->setValue("startup/versionPatch", QString(PACKAGE_PATCH_LEVEL).toInt());
+
+    settings->setValue("startup/checkJSON", checkJSON);
 }
 
 /* read the settings from config.ini */
@@ -560,6 +572,7 @@ void SettingsDialog::readSettings()
 
     /* project table */
     fontSize = settings->value("startup/fontSize",8).toInt();
+    rowSize = settings->value("startup/rowSize",25).toInt();
     automaticTimeSettings = settings->value("startup/automaticTimeSettings",1).toInt();
     automaticTimezoneFromDlt = settings->value("startup/automaticTimezoneFromDlt",1).toInt();
 
@@ -591,6 +604,9 @@ void SettingsDialog::readSettings()
     writeControl = settings->value("startup/writeControl",1).toInt();
     updateContextLoadingFile = settings->value("startup/updateContextLoadingFile",1).toInt();
     updateContextsUnregister = settings->value("startup/updateContextsUnregister",0).toInt();
+
+    storedSearchStr = settings->value("search/str").toString();
+    checkJSON = settings->value("startup/checkJSON").toInt();
 }
 
 
@@ -844,3 +860,22 @@ void SettingsDialog::clearIndexCacheAfterDays()
          if (!ui->groupBoxArguments->isChecked()) ui->groupBoxArguments->setChecked(true);
      }
     }
+
+
+    void SettingsDialog::addSearchStr( const std::string& str )
+    {
+        DltSettingsManager *settings = DltSettingsManager::getInstance();
+
+        settings->setValue( "search/str", str.c_str() );
+
+    }
+
+void SettingsDialog::on_jsonCheck_clicked(bool checked)
+{
+    checkJSON = checked;
+    if( checkJSON ){
+        ui->groupBoxArguments->setChecked(true);
+        showArguments = 1;
+        ui->spinBox_showArguments->setValue( showArguments );
+    }
+}
diff --git a/src/settingsdialog.h b/src/settingsdialog.h
index 2b1484e..4f7f1b4 100644
--- a/src/settingsdialog.h
+++ b/src/settingsdialog.h
@@ -95,8 +95,11 @@ public:
     int automaticTimezoneFromDlt;
     qlonglong utcOffset;
     int dst;
+    int rowSize;
+    int checkJSON;
 
     QString workingDirectory;
+    QFont my_font;
 
     void assertSettingsVersion();
 
@@ -113,10 +116,14 @@ public:
     QStringList getRecentFilters();
     QString getWorkingDirectory();
 
+    QString storedSearchStr;
+
     // this function checks if old cache files should be deleted
     // This function should be called during initialisation of dlt viewer
     void clearIndexCacheAfterDays();
 
+    void addSearchStr( const std::string& str );
+
 Q_SIGNALS:
     void FilterPathChanged();
 
@@ -145,6 +152,7 @@ private slots:
     void on_groupBoxArguments_clicked(bool checked);
     void on_spinBox_showArguments_valueChanged(int i);
 
+    void on_jsonCheck_clicked(bool checked);
 };
 
 #endif // SETTINGSDIALOG_H
diff --git a/src/settingsdialog.ui b/src/settingsdialog.ui
index a082a8d..3f65a19 100644
--- a/src/settingsdialog.ui
+++ b/src/settingsdialog.ui
@@ -6,8 +6,8 @@
    <rect>
     <x>0</x>
     <y>0</y>
-    <width>487</width>
-    <height>598</height>
+    <width>493</width>
+    <height>766</height>
    </rect>
   </property>
   <property name="windowTitle">
@@ -365,67 +365,6 @@
          </property>
          <layout class="QGridLayout" name="gridLayout_7">
           <item row="5" column="0">
-           <widget class="QGroupBox" name="groupBoxConId">
-            <property name="title">
-             <string>Show Context</string>
-            </property>
-            <property name="checkable">
-             <bool>true</bool>
-            </property>
-            <layout class="QHBoxLayout" name="horizontalLayout_3">
-             <item>
-              <widget class="QRadioButton" name="radioButtonConId">
-               <property name="text">
-                <string>Con Id</string>
-               </property>
-               <property name="checked">
-                <bool>true</bool>
-               </property>
-              </widget>
-             </item>
-             <item>
-              <widget class="QRadioButton" name="radioButtonConIdDesc">
-               <property name="text">
-                <string>Con Id Description</string>
-               </property>
-               <property name="checked">
-                <bool>false</bool>
-               </property>
-              </widget>
-             </item>
-            </layout>
-           </widget>
-          </item>
-          <item row="6" column="0">
-           <widget class="QGroupBox" name="groupBoxSessionId">
-            <property name="title">
-             <string>Show Session/Process Id</string>
-            </property>
-            <property name="checkable">
-             <bool>true</bool>
-            </property>
-            <layout class="QHBoxLayout" name="horizontalLayout_2">
-             <item>
-              <widget class="QRadioButton" name="radioButtonSessionId">
-               <property name="text">
-                <string>Session Id</string>
-               </property>
-               <property name="checked">
-                <bool>true</bool>
-               </property>
-              </widget>
-             </item>
-             <item>
-              <widget class="QRadioButton" name="radioButtonSessionName">
-               <property name="text">
-                <string>Session Name</string>
-               </property>
-              </widget>
-             </item>
-            </layout>
-           </widget>
-          </item>
-          <item row="4" column="0">
            <widget class="QGroupBox" name="groupBoxAppId">
             <property name="autoFillBackground">
              <bool>false</bool>
@@ -466,7 +405,7 @@
             </layout>
            </widget>
           </item>
-          <item row="7" column="0">
+          <item row="8" column="0">
            <widget class="QGroupBox" name="groupBoxAutomaticTimeSettings">
             <property name="title">
              <string>Set time column automatic to local recording time</string>
@@ -520,7 +459,7 @@
             <property name="minimumSize">
              <size>
               <width>0</width>
-              <height>53</height>
+              <height>56</height>
              </size>
             </property>
             <property name="title">
@@ -569,6 +508,67 @@
             </layout>
            </widget>
           </item>
+          <item row="6" column="0">
+           <widget class="QGroupBox" name="groupBoxConId">
+            <property name="title">
+             <string>Show Context</string>
+            </property>
+            <property name="checkable">
+             <bool>true</bool>
+            </property>
+            <layout class="QHBoxLayout" name="horizontalLayout_3">
+             <item>
+              <widget class="QRadioButton" name="radioButtonConId">
+               <property name="text">
+                <string>Con Id</string>
+               </property>
+               <property name="checked">
+                <bool>true</bool>
+               </property>
+              </widget>
+             </item>
+             <item>
+              <widget class="QRadioButton" name="radioButtonConIdDesc">
+               <property name="text">
+                <string>Con Id Description</string>
+               </property>
+               <property name="checked">
+                <bool>false</bool>
+               </property>
+              </widget>
+             </item>
+            </layout>
+           </widget>
+          </item>
+          <item row="7" column="0">
+           <widget class="QGroupBox" name="groupBoxSessionId">
+            <property name="title">
+             <string>Show Session/Process Id</string>
+            </property>
+            <property name="checkable">
+             <bool>true</bool>
+            </property>
+            <layout class="QHBoxLayout" name="horizontalLayout_2">
+             <item>
+              <widget class="QRadioButton" name="radioButtonSessionId">
+               <property name="text">
+                <string>Session Id</string>
+               </property>
+               <property name="checked">
+                <bool>true</bool>
+               </property>
+              </widget>
+             </item>
+             <item>
+              <widget class="QRadioButton" name="radioButtonSessionName">
+               <property name="text">
+                <string>Session Name</string>
+               </property>
+              </widget>
+             </item>
+            </layout>
+           </widget>
+          </item>
           <item row="1" column="0">
            <layout class="QGridLayout" name="gridLayout_3">
             <item row="5" column="0">
@@ -705,6 +705,26 @@
               </property>
              </widget>
             </item>
+            <item row="0" column="0" rowspan="2">
+             <widget class="QLabel" name="labelRowSize">
+              <property name="text">
+               <string>Rows size:</string>
+              </property>
+             </widget>
+            </item>
+            <item row="1" column="2">
+             <widget class="QSpinBox" name="spinBoxRowSize">
+              <property name="minimum">
+               <number>5</number>
+              </property>
+              <property name="maximum">
+               <number>100</number>
+              </property>
+              <property name="value">
+               <number>25</number>
+              </property>
+             </widget>
+            </item>
            </layout>
           </item>
           <item row="2" column="0">
@@ -720,6 +740,13 @@
             </property>
            </spacer>
           </item>
+          <item row="4" column="0">
+           <widget class="QCheckBox" name="jsonCheck">
+            <property name="text">
+             <string>Check JSON format</string>
+            </property>
+           </widget>
+          </item>
          </layout>
         </widget>
        </item>
diff --git a/src/src.pro b/src/src.pro
index 540c7eb..992a82a 100644
--- a/src/src.pro
+++ b/src/src.pro
@@ -121,7 +121,11 @@ SOURCES += main.cpp \
     exporterdialog.cpp \
     dltmsgqueue.cpp \
     dltfileindexerthread.cpp \
-    dltfileindexerdefaultfilterthread.cpp
+    dltfileindexerdefaultfilterthread.cpp \
+    qjsoncontainer.cpp \
+    qjsonitem.cpp \
+    qjsonmodel.cpp \
+    parse_json.cpp
 
 # Show these headers in the project
 HEADERS += mainwindow.h \
@@ -154,7 +158,11 @@ HEADERS += mainwindow.h \
     exporterdialog.h \
     dltmsgqueue.h \
     dltfileindexerthread.h \
-    dltfileindexerdefaultfilterthread.h
+    dltfileindexerdefaultfilterthread.h \
+    qjsoncontainer.h \
+    qjsonitem.h \
+    qjsonmodel.h \
+    parse_json.h
 
 # Compile these UI files
 FORMS += mainwindow.ui \
@@ -168,7 +176,8 @@ FORMS += mainwindow.ui \
     searchdialog.ui \
     multiplecontextdialog.ui \
     jumptodialog.ui \
-    exporterdialog.ui
+    exporterdialog.ui \
+    parse_json.ui
 
 # Related files
 OTHER_FILES += ../ReleaseNotes_Viewer.txt \
diff --git a/src/tablemodel.cpp b/src/tablemodel.cpp
index a9169c2..871742a 100644
--- a/src/tablemodel.cpp
+++ b/src/tablemodel.cpp
@@ -148,7 +148,7 @@ TableModel::TableModel(const QString & /*data*/, QObject *parent)
          {
          case FieldNames::Index:
              /* display index */
-             return QString("%L1").arg(qfile->getMsgFilterPos(index.row()));
+             return QString("%1").arg(qfile->getMsgFilterPos(index.row()));
          case FieldNames::Time:
              if( project->settings->automaticTimeSettings == 0 )
                 return QString("%1.%2").arg(msg.getGmTimeWithOffsetString(project->settings->utcOffset,project->settings->dst)).arg(msg.getMicroseconds(),6,10,QLatin1Char('0'));
@@ -252,7 +252,17 @@ TableModel::TableModel(const QString & /*data*/, QObject *parent)
              {
                  int col=index.column()-FieldNames::Arg0; //arguments a zero based
                  QDltArgument arg;
-                 if (msg.getArgument(col,arg))
+                 if( project->settings->checkJSON )
+                 {
+                     QString _payload = msg.toStringPayload().trimmed();
+                     if( *_payload.begin() == '{' && _payload.endsWith("}") )
+                     {
+                         QJsonDocument doc = QJsonDocument::fromJson( msg.toStringPayload().toUtf8() );
+                         if( doc.isNull() )return QString("FALSE");
+                         else return QString("OK");
+                     }else return QString(" - ");
+                 }
+                 else if (msg.getArgument(col,arg))
                  {
                      return arg.toString();
                  }
@@ -380,12 +390,34 @@ TableModel::TableModel(const QString & /*data*/, QObject *parent)
             case FieldNames::Mode:
                 return QVariant(Qt::AlignCenter | Qt::AlignVCenter);
             case FieldNames::ArgCount:
-                return QVariant(Qt::AlignRight  | Qt::AlignVCenter);
-            case FieldNames::Payload:
-                return QVariant(Qt::AlignLeft   | Qt::AlignVCenter);
+            return QVariant(Qt::AlignRight  | Qt::AlignVCenter);
+        case FieldNames::Payload:
+            return QVariant(Qt::AlignLeft   | Qt::AlignVCenter);
         }
-    }
+     }
+
+     if ( role == Qt::FontRole )
+     {
+         QFont tableViewFont = project->settings->my_font;
 
+         if(project->settings->autoMarkFatalError
+                 && index.column() == FieldNames::Payload
+                 && ( msg.getSubtypeString() == "error" || msg.getSubtypeString() == "fatal") )
+         {
+             tableViewFont.setBold(true);
+             return QVariant(tableViewFont);
+         }
+         if(project->settings->autoMarkWarn
+                 && index.column() == FieldNames::Payload
+                 && msg.getSubtypeString() == "warn")
+         {
+             tableViewFont.setItalic(true);
+             return QVariant(tableViewFont);
+         }
+
+         return QVariant(tableViewFont);
+
+     }
      return QVariant();
  }
 
